
import { aiService } from '../services/ai.service.ts';
import { logInfo, logError } from '../core/logger.ts';

export interface VulnerabilityReport {
  radicalismGap: {
    score: number;
    description: string;
    evidenceCitations: string[]; // Citações diretas das fontes
  };
  complexityPenalty: {
    score: number;
    description: string;
    technicalTerms: string[]; // Termos específicos que geram a penalidade
  };
  contradictions: {
    point: string;
    evidenceA: string;
    evidenceB: string;
  }[];
  attackVectors: {
    title: string;
    description: string;
    leverage: string; // O que o oponente usaria como "alavanca"
  }[];
  defenseStrategies: string[];
}

/**
 * VulnerabilityAuditor Agent
 * Especializado em detectar pontos fracos, lacunas de radicalismo e penalidades de complexidade no discurso político.
 */
export class VulnerabilityAuditor {
  private readonly promptTemplate = (politicianName: string, context: string) => `
Você é o Auditor de Vulnerabilidade Forense da Seth VII. Sua missão é identificar fragilidades estruturais no perfil de ${politicianName} usando RIGOR CIENTÍFICO.

EVIDÊNCIAS MINERADAS:
${context}

DIRETRIZES DE AUDITORIA:
1. RADICALISM GAP: Compare o discurso com a norma institucional. Use "evidenceCitations" para listar frases exatas das fontes.
2. COMPLEXITY PENALTY: Liste em "technicalTerms" as palavras ou conceitos que alienam o eleitor comum.
3. CONTRADIÇÕES: Identifique onde o político diz "A" mas a evidência mostra "B" ou onde há conflito entre fontes.
4. VETORES DE ATAQUE: Para cada vetor, identifique a "leverage" (a prova real que o oponente usaria).

Responda APENAS JSON:
{
  "radicalismGap": {
    "score": 0-100,
    "description": "...",
    "evidenceCitations": ["Citação 1", "Citação 2"]
  },
  "complexityPenalty": {
    "score": 0-100,
    "description": "...",
    "technicalTerms": ["Termo 1", "Termo 2"]
  },
  "contradictions": [
    { "point": "Assunto", "evidenceA": "Fato 1", "evidenceB": "Fato 2" }
  ],
  "attackVectors": [
    { "title": "Título", "description": "...", "leverage": "Prova factual" }
  ],
  "defenseStrategies": ["..."]
}
`;

  async audit(politicianName: string, evidences: any[]): Promise<VulnerabilityReport> {
    logInfo(`[VulnerabilityAuditor] Iniciando auditoria forense para: ${politicianName}`);

    const context = evidences
      .map(e => `[${e.category}] ${e.statement} (Fonte: ${e.sourceTitle})`)
      .join('\n');

    try {
      const prompt = this.promptTemplate(politicianName, context);
      
      // Usar o aiService para gerar o relatório estruturado
      // O aiService.analyzeText já lida com fallbacks e circuit breaker
      const result = await aiService.generateReport(prompt);
      
      // Tentar parsear o JSON da resposta
      const jsonMatch = result.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        throw new Error('Falha ao extrair JSON do relatório de vulnerabilidade');
      }

      const report: VulnerabilityReport = JSON.parse(jsonMatch[0]);
      logInfo(`[VulnerabilityAuditor] Auditoria concluída para ${politicianName}. Score de Radicalismo: ${report.radicalismGap.score}`);
      
      return report;
    } catch (error) {
      logError(`[VulnerabilityAuditor] Erro na auditoria de ${politicianName}:`, error as Error);
      return this.getFallbackReport();
    }
  }

  private getFallbackReport(): VulnerabilityReport {
    return {
      radicalismGap: { score: 0, description: "Não foi possível analisar o gap de radicalismo.", examples: [] },
      complexityPenalty: { score: 0, description: "Não foi possível analisar a penalidade de complexidade.", barriers: [] },
      strategicWeaknesses: ["Dados insuficientes para análise estratégica."],
      attackVectors: ["Dados insuficientes para identificar vetores de ataque."],
      defenseStrategies: ["Manter transparência e base factual."]
    };
  }
}

export const vulnerabilityAuditor = new VulnerabilityAuditor();
